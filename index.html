<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel Table Viewer</title>
  <!-- Include PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f4f4f4;
    }
    tbody tr:nth-child(even) {
      background-color: #d1d5db;
    }
    tbody tr:nth-child(odd) {
      background-color: #fff;
    }
    tbody tr:hover {
      background-color: #fde68a !important;
    }
    .formula {
      font-family: monospace;
      color: #007bff;
    }
    #csv-table-container {
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>Excel Table Viewer</h1>
  <form id="input-form" style="margin-bottom:20px;"></form>
  <label style="margin-bottom:10px;display:inline-block"><input type="checkbox" id="show-favorites"> Show only favorites</label>
  <div id="csv-table-container">
    <table id="excel-table"></table>
  </div>

  <script>
    const table = document.getElementById('excel-table');
    const form = document.getElementById('input-form');
    const showFavoritesCheckbox = document.getElementById('show-favorites');
    // Store favorites in localStorage
    let favoritesSet = new Set(JSON.parse(localStorage.getItem('favoritesSet') || '[]'));
    showFavoritesCheckbox.onchange = function() {
      renderTable(lastCsvData);
    };

    // List of fields to create integer inputs for
    const inputFields = [
      'BELNVO', 'MATNVO', 'Math', 'Bul', 'IT', 'Physics', 'English', 'Biology', 'Chemistry', 'Geo', 'History', 'Technology', 'Music', 'Art'
    ];
    // Map for renaming input fields in the view
    const inputFieldRenameMap = {
      'BELNVO': 'БЕЛ НВО',
      'MATNVO': 'МАТ НВО',
      'Math': 'Мат',
      'Bul': 'БЕЛ',
      'Art': 'Изобразително',
      'IT': 'Информационни технологии',
      'Music': 'Музика',
      'Physics': 'Физика',
      'English': 'Английски',
      'Biology': 'Биология',
      'Chemistry': 'Химия',
      'Geo': 'География',
      'History': 'История',
      'Technology': 'ТП'
    };

    // Render input fields and attach dynamic update
    let lastCsvData = null;
    function renderInputFields() {
      form.innerHTML = '';
      // Load cached values if present
      let cached = {};
      try {
        cached = JSON.parse(localStorage.getItem('inputFieldsCache') || '{}');
      } catch {}
      inputFields.forEach(field => {
        const label = document.createElement('label');
        label.textContent = (inputFieldRenameMap[field] || field) + ': ';
        label.style.marginRight = '8px';
        const input = document.createElement('input');
        input.type = 'number';
        input.name = field;
        input.step = '1';
        input.required = false;
        input.style.width = '60px';
        input.style.marginRight = '16px';
        if (cached[field] !== undefined) input.value = cached[field];
        input.oninput = function() {
          // Only allow integers
          this.value = this.value.replace(/[^\d-]/g, '');
          // Save to cache
          cached[field] = this.value;
          localStorage.setItem('inputFieldsCache', JSON.stringify(cached));
          if (lastCsvData) renderTable(lastCsvData);
        };
        label.appendChild(input);
        form.appendChild(label);
      });
    }
    renderInputFields();

    // Auto-load schoolsData.csv via fetch, try both comma and semicolon delimiters
    fetch('schoolsData.csv')
      .then(response => {
        if (!response.ok) throw new Error('CSV file not found');
        return response.text();
      })
      .then(csvText => {
        // Try comma first
        Papa.parse(csvText, {
          header: false,
          skipEmptyLines: true,
          complete: function(results) {
            if (results.data && results.data.length > 0 && results.data[0].length > 1) {
              renderTable(results.data);
            } else {
              // Try semicolon as fallback
              Papa.parse(csvText, {
                header: false,
                skipEmptyLines: true,
                delimiter: ';',
                complete: function(results2) {
                  renderTable(results2.data);
                }
              });
            }
          }
        });
      })
      .catch(err => {
        table.innerHTML = '<tr><td style="color:red">CSV file not found or failed to load.</td></tr>';
      });

    function renderTable(data) {
      lastCsvData = data;
      // Clear existing table
      table.innerHTML = '';

      // Get values from input fields as an object {FieldName: value}
      const inputValues = {};
      inputFields.forEach(field => {
        const el = form.querySelector(`[name="${field}"]`);
        inputValues[field] = el && el.value !== '' ? parseInt(el.value, 10) : 0;
      });

      // Helper: get value for a column name from input fields (case-insensitive)
      function getInputValueByCol(colName) {
        // Try exact, then case-insensitive
        if (inputValues.hasOwnProperty(colName)) return inputValues[colName];
        const key = Object.keys(inputValues).find(k => k.toLowerCase() === colName.toLowerCase());
        return key ? inputValues[key] : 0;
      }

      // Evaluate formula using input fields
      function evaluateFormulaFromInputs(formula) {
        try {
          let expr = formula.trim();
          if (expr.startsWith('=')) expr = expr.slice(1);
          // Replace all field names (words) with their input values from inputFields only
          expr = expr.replace(/([A-Za-z]+)/g, (name) => {
            // Only replace if the name is in inputFields (case-insensitive)
            const matchField = inputFields.find(f => f.toLowerCase() === name.toLowerCase());
            if (matchField) {
              return getInputValueByCol(matchField);
            }
            return name; // leave as is if not in inputFields
          });
          // Only allow numbers, operators, parentheses, and dots
          if (!/^[0-9+\-*/(). ]+$/.test(expr)) return 'N/A';
          return Function('return ' + expr)();
        } catch (e) {
          return 'N/A';
        }
      }

      if (!data || !data.length || !data[0].length) {
        table.innerHTML = '<tr><td style="color:red">No data found in CSV.</td></tr>';
        return;
      }

      // Find the index of the Formula_modified column
      const formulaColIdx = data[0].findIndex(h => h === 'Formula_modified');

      // Sorting state
      let sortCol = null;
      let sortDir = 1; // 1 = asc, -1 = desc

      // If already sorted, keep state
      if (window._tableSortCol !== undefined) {
        sortCol = window._tableSortCol;
        sortDir = window._tableSortDir;
      }

      // Prepare data for sorting (exclude header)
      let dataRows = data.slice(1);
      // Find visible columns (excluding Formula_modified)
      const visibleCols = data[0].map((h, i) => i).filter(i => i !== formulaColIdx);
      // We'll add Favorites as the first column

      // Render header
      const headerEl = document.createElement('thead');
      const headerRow = document.createElement('tr');
      // Favorites column header
      const favTh = document.createElement('th');
      favTh.textContent = '★';
      headerRow.appendChild(favTh);
      // Map for renaming columns in the view
      const colRenameMap = {
        'BELNVO': 'БЕЛ НВО',
        'MATNVO': 'МАТ НВО',
        'Math': 'Мат',
        'Bul': 'БЕЛ',
        'Art': 'Изобразително',
        'IT': 'Информационни технологии',
        'Music': 'Музика',
        'Physics': 'Физика',
        'English': 'Английски',
        'Biology': 'Биология',
        'Chemistry': 'Химия',
        'Geo': 'География',
        'History': 'История',
        'Technology': 'ТП'
      };

      // To move Art last and Music before Art, reorder visibleCols for those fields
      let reorderedCols = [...visibleCols];
      const artIdx = data[0].findIndex(h => h === 'Art');
      const musicIdx = data[0].findIndex(h => h === 'Music');
      if (artIdx !== -1 && musicIdx !== -1) {
        // Remove Art and Music from their current positions
        reorderedCols = reorderedCols.filter(i => i !== artIdx && i !== musicIdx);
        // Add Music before Art, and Art last
        reorderedCols.push(musicIdx);
        reorderedCols.push(artIdx);
      } else if (artIdx !== -1) {
        reorderedCols = reorderedCols.filter(i => i !== artIdx);
        reorderedCols.push(artIdx);
      }

      // Render headers with renaming and reordering
      reorderedCols.forEach((colIdx) => {
        const th = document.createElement('th');
        let headerName = data[0][colIdx];
        if (headerName === 'FormulaRow') headerName = 'FormulaRaw';
        if (colRenameMap[headerName]) headerName = colRenameMap[headerName];
        th.textContent = headerName;
        th.style.cursor = 'pointer';
        th.onclick = function() {
          if (sortCol === colIdx) {
            sortDir = -sortDir;
          } else {
            sortCol = colIdx;
            sortDir = 1;
          }
          window._tableSortCol = colIdx;
          window._tableSortDir = sortDir;
          renderTable(lastCsvData);
        };
        // Add sort indicator
        if (sortCol === colIdx) {
          th.textContent += sortDir === 1 ? ' ▲' : ' ▼';
        }
        headerRow.appendChild(th);
      });
      // Add Score and Probability headers with sorting
      const evalTh = document.createElement('th');
      evalTh.textContent = 'Score';
      evalTh.style.cursor = 'pointer';
      evalTh.onclick = function() {
        if (sortCol === 'score') {
          sortDir = -sortDir;
        } else {
          sortCol = 'score';
          sortDir = 1;
        }
        window._tableSortCol = sortCol;
        window._tableSortDir = sortDir;
        renderTable(lastCsvData);
      };
      if (sortCol === 'score') {
        evalTh.textContent += sortDir === 1 ? ' ▲' : ' ▼';
      }
      headerRow.appendChild(evalTh);
      const probTh = document.createElement('th');
      probTh.textContent = 'Probability';
      probTh.style.cursor = 'pointer';
      probTh.onclick = function() {
        if (sortCol === 'probability') {
          sortDir = -sortDir;
        } else {
          sortCol = 'probability';
          sortDir = 1;
        }
        window._tableSortCol = sortCol;
        window._tableSortDir = sortDir;
        renderTable(lastCsvData);
      };
      if (sortCol === 'probability') {
        probTh.textContent += sortDir === 1 ? ' ▲' : ' ▼';
      }
      headerRow.appendChild(probTh);
      headerEl.appendChild(headerRow);
      table.appendChild(headerEl);

      // Sort if needed
      if (sortCol !== null) {
        dataRows.sort((a, b) => {
          if (sortCol === 'score' || sortCol === 'probability') {
            let aScore = '', bScore = '';
            if (formulaColIdx !== -1 && a[formulaColIdx]) aScore = evaluateFormulaFromInputs(a[formulaColIdx]);
            if (formulaColIdx !== -1 && b[formulaColIdx]) bScore = evaluateFormulaFromInputs(b[formulaColIdx]);
            let aScoreNum = parseFloat(aScore);
            let bScoreNum = parseFloat(bScore);
            if (sortCol === 'score') {
              aScoreNum = isNaN(aScoreNum) ? 0 : aScoreNum;
              bScoreNum = isNaN(bScoreNum) ? 0 : bScoreNum;
              return (aScoreNum - bScoreNum) * sortDir;
            } else {
              function getProb(row, scoreVal) {
                let minLYIdx = data[0].findIndex(h => h.toLowerCase() === 'minly');
                let maxLYIdx = data[0].findIndex(h => h.toLowerCase() === 'maxly');
                let minLY = minLYIdx !== -1 ? parseFloat(row[minLYIdx]) : null;
                let maxLY = maxLYIdx !== -1 ? parseFloat(row[maxLYIdx]) : null;
                let score = parseFloat(scoreVal);
                if (!isNaN(score)) {
                  if (
                    minLY !== null && !isNaN(minLY) &&
                    maxLY !== null && !isNaN(maxLY) &&
                    score >= minLY && score <= maxLY
                  ) {
                    return 3; // HIGH
                  } else if (maxLY !== null && !isNaN(maxLY) && score > maxLY) {
                    return 3; // HIGH
                  } else if (minLY !== null && !isNaN(minLY)) {
                    if (Math.abs(score - minLY) <= 15) {
                      return 2; // MEDIUM
                    } else if (minLY > score + 50) {
                      return 1; // LOW
                    } else if (score < minLY) {
                      return 1; // LOW
                    } else {
                      return 0;
                    }
                  } else {
                    return 0;
                  }
                }
                return 0;
              }
              let aProb = getProb(a, aScore);
              let bProb = getProb(b, bScore);
              return (aProb - bProb) * sortDir;
            }
          } else {
            let av = a[sortCol], bv = b[sortCol];
            let an = parseFloat(av), bn = parseFloat(bv);
            if (!isNaN(an) && !isNaN(bn)) {
              return (an - bn) * sortDir;
            }
            return (av + '').localeCompare(bv + '') * sortDir;
          }
        });
      }

      // Render body
      const tbody = document.createElement('tbody');
      dataRows.forEach((row, rowIdx) => {
        // Use a unique key for the row, e.g., join all visible columns
        const rowKey = visibleCols.map(i => row[i]).join('||');
        // If show only favorites is checked, skip non-favorites
        if (showFavoritesCheckbox.checked && !favoritesSet.has(rowKey)) return;
        const rowEl = document.createElement('tr');
        // Favorites cell
        const favTd = document.createElement('td');
        favTd.style.textAlign = 'center';
        favTd.style.cursor = 'pointer';
        favTd.title = 'Toggle favorite';
        favTd.textContent = favoritesSet.has(rowKey) ? '★' : '☆';
        favTd.onclick = function(e) {
          e.stopPropagation();
          if (favoritesSet.has(rowKey)) {
            favoritesSet.delete(rowKey);
          } else {
            favoritesSet.add(rowKey);
          }
          localStorage.setItem('favoritesSet', JSON.stringify(Array.from(favoritesSet)));
          renderTable(lastCsvData);
        };
        rowEl.appendChild(favTd);
        // Use reorderedCols for body as well
        reorderedCols.forEach((colIndex) => {
          let cellEl = document.createElement('td');
          let colName = data[0][colIndex];
          let displayValue = row[colIndex];
          cellEl.textContent = displayValue;
          rowEl.appendChild(cellEl);
        });
        // Score (was Evaluated Value)
        let evalValue = '';
        if (formulaColIdx !== -1 && row[formulaColIdx]) {
          evalValue = evaluateFormulaFromInputs(row[formulaColIdx]);
        }
        const td = document.createElement('td');
        td.textContent = evalValue;
        rowEl.appendChild(td);

        // Probability column
        let probTd = document.createElement('td');
        let probText = '';
        let probColor = '';
        // Find MinLY and MaxLY columns (case-insensitive)
        let minLYIdx = data[0].findIndex(h => h.toLowerCase() === 'minly');
        let maxLYIdx = data[0].findIndex(h => h.toLowerCase() === 'maxly');
        let minLY = minLYIdx !== -1 ? parseFloat(row[minLYIdx]) : null;
        let maxLY = maxLYIdx !== -1 ? parseFloat(row[maxLYIdx]) : null;
        let score = parseFloat(evalValue);
        let rowBg = '';
        if (!isNaN(score)) {
          if (
            minLY !== null && !isNaN(minLY) &&
            maxLY !== null && !isNaN(maxLY) &&
            score >= minLY && score <= maxLY
          ) {
            probText = 'HIGH';
            probColor = 'green';
            rowBg = '#d1fae5'; // light green
          } else if (maxLY !== null && !isNaN(maxLY) && score > maxLY) {
            probText = 'HIGH';
            probColor = 'green';
            rowBg = '#d1fae5';
          } else if (minLY !== null && !isNaN(minLY)) {
            if (Math.abs(score - minLY) <= 15) {
              probText = 'MEDIUM';
              probColor = 'orange';
              rowBg = '#fef9c3'; // light yellow
            } else if (minLY > score + 50) {
              probText = 'LOW';
              probColor = 'red';
              rowBg = '#fee2e2'; // light red
            } else if (score < minLY) {
              probText = 'LOW';
              probColor = 'red';
              rowBg = '#fee2e2';
            } else {
              probText = '';
              probColor = '';
            }
          } else {
            probText = '';
            probColor = '';
          }
        }
        probTd.textContent = probText;
        if (probColor) probTd.style.color = probColor;
        rowEl.appendChild(probTd);

        // Set row background color based on probability
        if (rowBg) {
          rowEl.style.backgroundColor = rowBg;
        }

        tbody.appendChild(rowEl);
      });
      table.appendChild(tbody);
    }
  </script>
</body>
</html>
